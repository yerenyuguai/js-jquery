<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
<!-- 1.理解  就像是一块地盘，一个代码所在的区域
           它是静态的(相当于上下文对象)，在编写代码的时候就确定了
    2.分类  
           全局作用域
           函数作用域
           块作用域（ES6出现） 即为{}里
    3 作用  隔离变量，不同作用域下同名变量不会有冲突 -->
</head>
<body>
</body>
<script type="text/javascript">
    if(true){
        var c=3;
        let d=3;
    }
    console.log(c);
  //console.log(d);  d是let定义的，let的声明范围是块作用域，而var声明的范围是函数作用域,块级作用域是函数作用域的子集

  var a=10,b=20;
  function fn(x){
      var a=100,c=300;
      console.log("fn()",a,b,c,x);// b先在函数内部找，找不到就去函数外
      function bar(x){//不要被fn()里的x迷惑，不是一样的 隔离变量，不同作用域下同名变量不会有冲突
          var a=1000,d=400;//
          console.log('bar()',a,b,c,d,x);
      }
      bar(100)
      bar(200)
  }
  fn(10);
  //上下文的代码在执行的视乎，会创建变量对象的一个作用域链，作用域链决定了各级上下文中代码的访问变量和函数时的顺序

  /*
  1.区别
全局作用城之外，每个函数都会创建自己的作用域(n+1)，作用域在函数定义时就已经确定了。而不是在函数调用时，跟函数调用没关系
全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
函数执行上下文环境是在调用函数时，函数体代码执行之前创建
2.区别2
作用域是静态的， 只要函数定义好了就一-直存在， 且不会再变化
上下文环境是动态的，调用函数时创建， 函数调用结束时 上下文环境就会被释放
3.联系
上下文环境(对象)是从属于所在的作用域
全局上下文环境==>全局作用域
函数上下文环境==>对应的函数使用域



1.理解
*多个上下级关系的作用域形成的链， 它的方向是从下向上的(从内到外)
*查找变量时就是沿着作用域链来查找的
2. 查找一个变量的查找规则
在当前作用域下的执行上下文中查找对应的属性，如果有直接返回， 否则进入上一级
在上一级作用域的执行上下文中查找对应的属性，如果有直接返回， 否则进入上一级
再次执行2的相同操作，直到全局作用域， 如果还找 不到就抛出找不到的异常
  */

  var x=10;
  function fn(){
      console.log(x);
  }
  function show(f){
      var x=20;
      f();             //相当于调用fn()
  }
  show(fn);           //将fn这个函数传进去
  //这时候或许理所应当认为，在fn（）没有x,就去show里找，发现20，其实并不是
  //函数上下文(作用域)在函数定义是就已经确定了，而不是在函数调用时，不会更改变化
  //这样的话实际上fn()和show()不是包含的作用域，各自一个区域在全局内，所以fn()找的时候，内部没有
  //就跳出外部，在这里就是全局里找，找到x为10，show()和他相当于是同一级别的作用域
  //(变量提升是在自己作用域内提升)


  var fn=function(){
      console.log(fn);
  }
  fn()//输出整个函数

  var obj={
      fn2:function(){
          console.log(fn2);
      }
  }
  //obj.fn2();  
  //会报错  首先要输出 console.log(fn2); 没有找到这个变量，外部作用域也没有
  // fn2:function(){}  这里的fn2是一个方法，如果想找到需要  console.log(this.fn2);  this就是obj
</script>
</html>